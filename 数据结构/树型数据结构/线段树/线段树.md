# 线段树

### 模板1
```cpp
#include<iostream>
#define mid ((lline+rline)>>1)
#define ls (pos<<1)
#define rs ((pos<<1)|1)
#define leng (rline-lline+1)

using namespace std;

long long n,Q,a[200005],lef,rig,val;
long long tree[400005],lz[400005];

long long build(long long pos,long long lline,long long rline)
{
	if (lline==rline) return (tree[pos]=a[lline]);
	return (tree[pos]=build(ls,lline,mid)+build(rs,mid+1,rline));
}

inline void downdate(long long pos,long long lline,long long rline)
{
	lz[ls]+=lz[pos]; lz[rs]+=lz[pos];
	tree[ls]+=((mid-lline+1)*lz[pos]);
	tree[rs]+=((rline-(mid+1)+1)*lz[pos]);
	lz[pos]=0;
}

long long add(long long pos,long long lline,long long rline)
{
	if (lline!=rline) downdate(pos,lline,rline);
	if (lef<=lline && rline<=rig) {lz[pos]+=val; return (tree[pos]+=val*leng);}
	if (rig<lline || lef>rline) return tree[pos];
	return (tree[pos]=add(ls,lline,mid)+add(rs,mid+1,rline));
}

long long query(long long pos,long long lline,long long rline)
{
	if (lline!=rline) downdate(pos,lline,rline);
	if (lef<=lline && rline<=rig) return tree[pos];
	if (rig<lline || lef>rline) return 0;
	return (query(ls,lline,mid)+query(rs,mid+1,rline));
}

int main()
{
	cin>>n>>Q;
	for (long long i=1;i<=n;i++) cin>>a[i];
	build(1,1,n);
	for (long long i=1,type;i<=Q;i++)
		{
			cin>>type;
			if (type==1){
				cin>>lef>>rig>>val;
				add(1,1,n);
			}else{
				cin>>lef>>rig;
				cout<<query(1,1,n)<<endl;
			}
		}
}
// 代码由smzzl提供
```
